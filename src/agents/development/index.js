const GitHubService = require('../../services/github');
const LinearService = require('../../services/linear');
const CodeGeneratorService = require('../../services/code-generator');
const logger = require('../../utils/logger');

/**
 * DevelopmentAgent - Autonomous code generation and repository management
 * 
 * Capabilities:
 * - Generate production-ready code from Linear issue specifications
 * - Create branches, commit code, and open pull requests
 * - Request automated code reviews from GitHub Copilot
 * - Update Linear issues with progress and PR links
 * 
 * @class DevelopmentAgent
 */
class DevelopmentAgent {
  /**
   * @param {Object} config - Configuration object
   * @param {Object} config.github - GitHub API configuration
   * @param {Object} config.linear - Linear API configuration
   * @param {Object} config.openai - OpenAI API configuration
   */
  constructor(config) {
    this.github = new GitHubService(config.github);
    this.linear = new LinearService(config.linear);
    this.codeGenerator = new CodeGeneratorService(config.openai);
    this.config = config;
    
    logger.info('[DevelopmentAgent] Initialized with full integration capabilities');
  }

  /**
   * Handle Linear issue events for automated development workflow
   * 
   * @param {Object} event - Linear webhook event
   * @param {Object} event.issue - Issue object from Linear
   * @param {string} event.action - Event action (created, updated)
   * @returns {Promise<Object>} Result with PR URL and status
   */
  async handleIssueEvent(event) {
    const { issue, action } = event;
    
    try {
      logger.info(`[DevelopmentAgent] Processing ${action} event for ${issue.identifier}`);

      // 1. Parse issue for technical specifications
      const specs = await this.parseIssueSpecs(issue);
      
      if (!specs.isImplementable) {
        logger.warn(`[DevelopmentAgent] Issue ${issue.identifier} not implementable - missing technical specs`);
        return { success: false, reason: 'insufficient_specs' };
      }

      // 2. Generate implementation plan with file structure
      logger.info(`[DevelopmentAgent] Generating implementation plan for ${issue.identifier}`);
      const plan = await this.codeGenerator.generatePlan(specs);
      
      // 3. Create feature branch
      const branchName = `feature/${issue.identifier.toLowerCase()}`;
      logger.info(`[DevelopmentAgent] Creating branch: ${branchName}`);
      
      const branch = await this.github.createBranch({
        owner: this.config.github.owner,
        repo: this.config.github.repo,
        branch: branchName,
        from_branch: this.config.github.baseBranch || 'main'
      });

      // 4. Generate and commit files
      logger.info(`[DevelopmentAgent] Generating ${plan.files.length} files`);
      const commitResults = [];
      
      for (const fileSpec of plan.files) {
        const code = await this.codeGenerator.generateCode({
          ...fileSpec,
          context: plan.context,
          issueSpecs: specs
        });
        
        const commitResult = await this.github.createOrUpdateFile({
          owner: this.config.github.owner,
          repo: this.config.github.repo,
          branch: branchName,
          path: fileSpec.path,
          content: code,
          message: `feat: ${fileSpec.description}\n\nGenerated by DevelopmentAgent for ${issue.identifier}`
        });
        
        commitResults.push(commitResult);
        logger.info(`[DevelopmentAgent] Committed ${fileSpec.path}`);
      }

      // 5. Open pull request with detailed description
      const prDescription = this.generatePRDescription(plan, specs, issue);
      
      logger.info(`[DevelopmentAgent] Creating pull request`);
      const pr = await this.github.createPullRequest({
        owner: this.config.github.owner,
        repo: this.config.github.repo,
        head: branchName,
        base: this.config.github.baseBranch || 'main',
        title: issue.title,
        body: prDescription,
        draft: false,
        maintainer_can_modify: true
      });

      // 6. Request GitHub Copilot review
      try {
        await this.github.requestCopilotReview({
          owner: this.config.github.owner,
          repo: this.config.github.repo,
          pullNumber: pr.number
        });
        logger.info(`[DevelopmentAgent] Requested Copilot review for PR #${pr.number}`);
      } catch (reviewError) {
        logger.warn(`[DevelopmentAgent] Could not request Copilot review: ${reviewError.message}`);
      }

      // 7. Update Linear issue with progress and PR link
      const updatedDescription = `${issue.description}\n\n---\n\n## üöÄ Development Progress\n\n‚úÖ **Pull Request Created**: [#${pr.number}](${pr.html_url})\n‚öôÔ∏è **Branch**: \`${branchName}\`\nüìÑ **Files Changed**: ${plan.files.length}\nüîç **Status**: Awaiting review\n\n*Generated by DevelopmentAgent at ${new Date().toISOString()}*`;
      
      await this.linear.updateIssue(issue.id, {
        description: updatedDescription,
        state: 'In Review'
      });
      
      logger.info(`[DevelopmentAgent] Updated Linear issue ${issue.identifier} with PR link`);

      return {
        success: true,
        pr: {
          number: pr.number,
          url: pr.html_url,
          branch: branchName
        },
        filesGenerated: plan.files.length,
        commits: commitResults.length
      };

    } catch (error) {
      logger.error(`[DevelopmentAgent] Error processing ${issue.identifier}: ${error.message}`, error);
      
      // Update Linear issue with error status
      try {
        await this.linear.createComment(issue.id, {
          body: `‚ö†Ô∏è **DevelopmentAgent Error**\n\nFailed to generate code: ${error.message}\n\nPlease review the issue specifications and try again.`
        });
      } catch (commentError) {
        logger.error(`[DevelopmentAgent] Could not post error comment: ${commentError.message}`);
      }

      throw error;
    }
  }

  /**
   * Parse Linear issue for technical specifications
   * 
   * @param {Object} issue - Linear issue object
   * @returns {Promise<Object>} Parsed specifications with implementability flag
   */
  async parseIssueSpecs(issue) {
    const { title, description, labels } = issue;
    
    // Extract technical requirements from description
    const hasCodeBlock = /```/.test(description || '');
    const hasArchitecture = /architecture|design|structure/i.test(description || '');
    const hasAcceptanceCriteria = /acceptance criteria|success criteria|requirements/i.test(description || '');
    const hasImplementationDetails = /implementation|technical|api|interface/i.test(description || '');
    
    // Check labels for technical indicators
    const technicalLabels = labels.filter(label => 
      /feature|enhancement|bug|refactor|tech/i.test(label.name)
    );
    
    const isImplementable = (
      hasCodeBlock ||
      (hasArchitecture && hasImplementationDetails) ||
      (hasAcceptanceCriteria && description.length > 200)
    );
    
    return {
      title,
      description: description || '',
      labels: labels.map(l => l.name),
      isImplementable,
      technicalScore: [
        hasCodeBlock,
        hasArchitecture,
        hasAcceptanceCriteria,
        hasImplementationDetails,
        technicalLabels.length > 0
      ].filter(Boolean).length,
      requirements: this.extractRequirements(description || ''),
      priority: issue.priority,
      estimate: issue.estimate
    };
  }

  /**
   * Extract structured requirements from issue description
   * 
   * @param {string} description - Issue description text
   * @returns {Object} Structured requirements
   */
  extractRequirements(description) {
    const requirements = {
      features: [],
      constraints: [],
      dependencies: [],
      apis: []
    };
    
    // Extract bullet points as features
    const bulletPoints = description.match(/^[\s]*[-*]\s+(.+)$/gm) || [];
    requirements.features = bulletPoints.map(bp => bp.replace(/^[\s]*[-*]\s+/, '').trim());
    
    // Extract code blocks for API/interface definitions
    const codeBlocks = description.match(/```[\s\S]*?```/g) || [];
    requirements.apis = codeBlocks;
    
    // Extract @mentions as dependencies
    const mentions = description.match(/@[\w-]+/g) || [];
    requirements.dependencies = mentions;
    
    return requirements;
  }

  /**
   * Generate comprehensive PR description
   * 
   * @param {Object} plan - Implementation plan from code generator
   * @param {Object} specs - Parsed specifications
   * @param {Object} issue - Original Linear issue
   * @returns {string} Formatted PR description in Markdown
   */
  generatePRDescription(plan, specs, issue) {
    return `## üéØ Overview

${issue.title}

**Linear Issue**: [${issue.identifier}](${issue.url})
**Priority**: ${this.priorityLabel(specs.priority)}
**Estimate**: ${specs.estimate || 'Not specified'} points

## üìã Changes

${plan.files.map(f => `- \`${f.path}\`: ${f.description}`).join('\n')}

## üõ†Ô∏è Implementation Details

${plan.summary || 'Auto-generated implementation based on issue specifications.'}

### Architecture

${plan.architecture || 'Standard modular architecture with separation of concerns.'}

### Key Features

${specs.requirements.features.slice(0, 5).map(f => `- ${f}`).join('\n')}

## ‚úÖ Testing

- [ ] Unit tests generated (target >80% coverage)
- [ ] Integration tests for API endpoints
- [ ] Linting passes without errors
- [ ] Build succeeds without warnings

## üîó Related Issues

- Closes ${issue.identifier}
${specs.requirements.dependencies.map(d => `- Related: ${d}`).join('\n')}

## ü§ñ Generated by DevelopmentAgent

This pull request was automatically generated by the Tree of Life Development Agent.

**Technical Score**: ${specs.technicalScore}/5
**Files Generated**: ${plan.files.length}
**Lines of Code**: ~${plan.estimatedLOC || 'TBD'}

---

*Generated at ${new Date().toISOString()}*`;
  }

  /**
   * Convert priority number to human-readable label
   * 
   * @param {number} priority - Priority value (0-4)
   * @returns {string} Priority label with emoji
   */
  priorityLabel(priority) {
    const labels = {
      0: '‚è∫ No Priority',
      1: 'üî¥ Urgent',
      2: 'üü† High',
      3: 'üü° Medium',
      4: 'üü¢ Low'
    };
    return labels[priority] || '‚è∫ No Priority';
  }
}

module.exports = DevelopmentAgent;
